export const codeString =
` /**
 * Интерфейс Команды объявляет метод для выполнения команд.
 */
interface Command {
    execute(): void;
}

/**
 * Некоторые команды способны выполнять простые операции
 * самостоятельно.
 */
class SimpleCommand implements Command {
    private payload: string;

    constructor(payload: string) {
        this.payload = payload;
    }

    public execute(): void {
        console.log(
        \`SimpleCommand: See, I can do simple things 
        like printing ($\{this.payload})\`);
    }
}

/**
 * Но есть и команды, которые делегируют более сложные операции
 * другим объектам, называемым «получателями».
 */
class ComplexCommand implements Command {
    private receiver: Receiver;

    /**
     * Данные о контексте, необходимые для запуска методов
     * получателя.
     */
    private a: string;

    private b: string;

    /**
     * Сложные команды могут принимать один или несколько
     * объектов-получателей вместе с любыми данными о контексте
     * через конструктор.
     */
    constructor(receiver: Receiver, a: string, b: string) {
        this.receiver = receiver;
        this.a = a;
        this.b = b;
    }

    /**
     * Команды могут делегировать выполнение любым методам
     * получателя.
     */
    public execute(): void {
        console.log(
        'ComplexCommand: Complex stuff should be done
         by a receiver object.'
        );
        this.receiver.doSomething(this.a);
        this.receiver.doSomethingElse(this.b);
    }
}

/**
 * Классы Получателей содержат некую важную бизнес-логику.
 * Они умеют выполнять все виды операций, связанных с выполнением
 * запроса. Фактически, любой класс может выступать Получателем.
 */
class Receiver {
    public doSomething(a: string): void {
        console.log(\`Receiver: Working on ($\{a}.)\`);
    }

    public doSomethingElse(b: string): void {
        console.log(\`Receiver: Also working on ($\{b}.)\`);
    }
}

/**
 * Отправитель связан с одной или несколькими командами. Он
 * отправляет запрос команде.
 */
class Invoker {
    private onStart: Command;

    private onFinish: Command;

    /**
     * Инициализация команд.
     */
    public setOnStart(command: Command): void {
        this.onStart = command;
    }

    public setOnFinish(command: Command): void {
        this.onFinish = command;
    }

    /**
     * Отправитель не зависит от классов конкретных команд
     * и получателей. Отправитель передаёт запрос получателю
     * косвенно, выполняя команду.
     */
    public doSomethingImportant(): void {
        console.log(
        'Invoker: Does anybody want something done before I begin?'
        );
        if (this.isCommand(this.onStart)) {
            this.onStart.execute();
        }

        console.log(
        'Invoker: ...doing something really important...'
        );

        console.log(
        'Invoker: Does anybody want something done after I finish?'
        );
        if (this.isCommand(this.onFinish)) {
            this.onFinish.execute();
        }
    }

    private isCommand(object): object is Command {
        return object.execute !== undefined;
    }
}
  `;

export const description = [
  `Команда (англ. Command) — поведенческий шаблон проектирования, используемый при объектно-ориентированном 
   программировании, представляющий действие. Объект команды заключает в себе само действие и его параметры.`,
  `Он служит для заворачивания запросов или простых операций в отдельные объекты, что позволяет откладывать выполнение команд,
   выстраивать их в очереди, а также хранить историю и делать отмену.`,
  `Цель:`,
  `Создание структуры, в которой класс-отправитель и класс-получатель не зависят друг от друга напрямую.
   Организация обратного вызова к классу, который включает в себя класс-отправитель.`,
  `Описание:`,
  `В объектно-ориентированном программировании шаблон проектирования Команда является поведенческим шаблоном, в котором
   объект используется для инкапсуляции всей информации, необходимой для выполнения действия или вызова события в более позднее время.`,
  `Эта информация включает в себя имя метода, объект, который является владельцем метода и значения параметров метода.`,
  `Четыре термина всегда связаны с шаблоном Команда: команды (command), приёмник команд (receiver), вызывающий команды (invoker) и клиент (client).`,
  `Объект Command знает о приёмнике и вызывает метод приемника. Значения параметров приёмника сохраняются в команде.
   Вызывающий объект (invoker) знает, как выполнить команду и, возможно, делает учёт и запись выполненных команд. `,
  `Вызывающий объект (invoker) ничего не знает о конкретной команде, он знает только об интерфейсе. Оба объекта 
   (вызывающий объект и несколько объектов команд) принадлежат объекту клиента (client). Клиент решает, какие команды выполнить 
   и когда. Чтобы выполнить команду он передает объект команды вызывающему объекту (invoker).`,
  `Использование командных объектов упрощает построение общих компонентов, которые необходимо делегировать или выполнять
   вызовы методов в любое время без необходимости знать методы класса или параметров метода.`,
  `Использование вызывающего объекта (invoker) позволяет вести учёт выполненных команд без необходимости знать клиенту 
   об этой модели учёта (такой учёт может пригодиться, например, для реализации отмены и повтора команд).`,
  `Применение:`,
  `1) Кнопки пользовательского интерфейса и пункты меню`,
  `В Swing и Borland Delphi Action (действие) является объектом команды. В дополнение к способности выполнить нужную 
   команду, Action может иметь связанную с ним иконку, сочетание клавиш, текст всплывающей подсказки и так далее. 
   Кнопка на панели инструментов или пункт меню могут быть полностью инициализированы с использованием только объекта Action.`,
  `2) Запись макросов`,
  `Если все действия пользователя представлены в виде объектов команды, программа может записать последовательность действий,
   просто сохраняя список командных объектов в том порядке, в котором они выполняются. Затем она может «воспроизвести» 
   одни и те же действия, выполняя те же объекты команд в той же последовательности.`,
  `3) Многоуровневая отмена операций (Undo)`,
  `Если все действия пользователя в программе реализованы в виде командных объектов, программа может сохранить стек
   последних выполненных команд. Когда пользователь хочет отменить команду, программа просто выталкивает последний объект 
   команды и выполняет его метод undo().`,
  `4) Сети`,
  `Можно отправить объекты команд по сети для выполнения на другой машине, например действие игрока в компьютерной игре.`,
  `5) Индикаторы выполнения`,
  `Предположим, что программа имеет последовательность команд, которые она выполняет по порядку. Если каждый объект 
   команды имеет метод getEstimatedDuration() (получить оценочную длительность), программа может легко оценить общую 
   продолжительность процесса. Она может показать индикатор выполнения, который отражает, насколько близка программа к завершению всех задач.`,
  `6) Пулы потоков`,
  `Типичный класс пула потоков общего назначения может иметь метод addTask(), который добавляет рабочий элемент к
   внутренней очереди заданий ожидающих своего выполнения. Он поддерживает пул потоков, которые выполняют команды из 
   очереди. Элементы в очереди являются объектами команд. Как правило, эти объекты реализуют общий интерфейс, 
   такой как java.lang.Runnable, что позволяет пулу потоков запустить команды на выполнение, даже если он сам был 
   написан без каких-либо знаний о конкретных задачах, для которых он будет использоваться.`,
  `7) Транзакции`,
  `Аналогично операции «отмена» система управления базами данных (СУБД) или установщик программного обеспечения может 
   хранить список операций, которые были или будут выполнены. Если одна из них закончится неудачей, то все остальные могут 
   быть отменены или быть отброшены (обычно называется откат). Например, если две связанные между собой таблицы базы данных 
   должны быть обновлены, а второе обновление терпит неудачу, то система может откатить транзакцию, чтобы первая таблица не 
   содержала недопустимую ссылку.`,
  `8) Мастера`,
  `Часто мастер (мастер установки или любой другой) представляет несколько страниц конфигурации для одного действия, 
   которое происходит только тогда, когда пользователь нажимает на кнопку «Готово» на последней странице. В этих случаях, 
   естественный способ отделить код пользовательского интерфейса от кода приложения является реализация мастера с помощью 
   объекта команд. Объект команда создается при первом отображении мастера. Каждая страница мастера сохраняет свои изменения 
   в объекте команды, поэтому объект заполняется по мере перехода пользователя. Кнопка «Готово» просто запускает метод execute() 
   на выполнение.`,
];
