export const codeString =
`/**
 * Класс Создатель объявляет фабричный метод, который должен
 * возвращать объект класса Продукт. Подклассы Создателя обычно
 * предоставляют реализацию этого метода.
 */
abstract class Creator {
    /**
     * Обратите внимание, что Создатель может также обеспечить
     * реализацию фабричного метода по умолчанию.
     */
    public abstract factoryMethod(): Product;

    /**
     * Также заметьте, что, несмотря на название, основная
     * обязанность Создателяне заключается в создании продуктов.
     * Обычно он содержит некоторую базовую бизнес-логику,
     * которая основана на объектах Продуктов, возвращаемых 
     * фабричным методом. Подклассы могут косвенно изменять 
     * эту бизнес-логику, переопределяя фабричный метод и 
     * возвращая из него другой тип продукта.
     */
    public someOperation(): string {
        // Вызываем фабричный метод, чтобы получить объект-продукт.
        const product = this.factoryMethod();
        // Далее, работаем с этим продуктом.
        return
         \`Creator: The same creator's code has 
         just worked with $\{product.operation()}\`;
    }
}

/**
 * Конкретные Создатели переопределяют фабричный метод для того,
 * чтобы изменить тип результирующего продукта.
 */
class ConcreteCreator1 extends Creator {
    /**
     * Обратите внимание, что сигнатура метода по-прежнему 
     * использует тип абстрактного продукта, хотя фактически 
     * из метода возвращается конкретный продукт. Таким образом,
     * Создатель может оставаться независимым от конкретных классов
     * продуктов.
     */
    public factoryMethod(): Product {
        return new ConcreteProduct1();
    }
}

class ConcreteCreator2 extends Creator {
    public factoryMethod(): Product {
        return new ConcreteProduct2();
    }
}

/**
 * Интерфейс Продукта объявляет операции, которые должны выполнять
 * все конкретные продукты.
 */
interface Product {
    operation(): string;
}

/**
 * Конкретные Продукты предоставляют различные реализации
 * интерфейса Продукта.
 */
class ConcreteProduct1 implements Product {
    public operation(): string {
        return '{Result of the ConcreteProduct1}';
    }
}

class ConcreteProduct2 implements Product {
    public operation(): string {
        return '{Result of the ConcreteProduct2}';
    }
}

  `;

export const description = [
  `Фабричный метод (англ. Factory Method), или виртуальный конструктор (англ. Virtual Constructor) — порождающий шаблон
   проектирования, предоставляющий подклассам (дочерним классам) интерфейс для создания экземпляров некоторого класса.`,
  `это порождающий паттерн проектирования, который решает проблему создания различных продуктов, 
  без указания конкретных классов продуктов.`,
  `Фабричный метод задаёт метод, который следует использовать вместо вызова оператора new для создания объектов-продуктов.
   Подклассы могут переопределить этот метод, чтобы изменять тип создаваемых продуктов.`,
  `В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует
   создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические
    классы, а манипулировать абстрактными объектами на более высоком уровне`,
  `Цель:`,
  `Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, на основании какого класса 
  создавать объект. Фабричный метод позволяет классу делегировать создание подклассов.`,
  `Используется, когда:`,
  ` - классу заранее неизвестно, объекты каких подклассов ему нужно создавать.`,
  ` - класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами.`,
  ` - класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать 
  знание о том, какой класс принимает эти обязанности на себя.`,
  `Достоинства:`,
  ` - позволяет сделать код создания объектов более универсальным, не привязываясь к конкретным классам,
   а оперируя лишь общим интерфейсом;`,
  `Недостатки:`,
  ` - необходимость создавать наследника для каждого нового типа продукта;`,
];
