export const codeString =
`/**
 * Интерфейс Компонента объявляет метод accept, который в качестве
 * аргумента может получать любой объект, реализующий интерфейс
 * посетителя.
 */
interface Component {
    accept(visitor: Visitor): void;
}

/**
 * Каждый Конкретный Компонент должен реализовать метод accept
 * таким образом, чтобы он вызывал метод посетителя,
 * соответствующий классу компонента.
 */
class ConcreteComponentA implements Component {
    /**
     * Обратите внимание, мы вызываем visitConcreteComponentA,
     * что соответствует названию текущего класса. Таким образом мы
     * позволяем посетителю узнать, с каким классом компонента он
     * работает.
     */
    public accept(visitor: Visitor): void {
        visitor.visitConcreteComponentA(this);
    }

    /**
     * Конкретные Компоненты могут иметь особые методы, не
     * объявленные в их базовом классе или интерфейсе.
     * Посетитель всё же может использовать эти методы, поскольку
     * он знает о конкретном классе компонента.
     */
    public exclusiveMethodOfConcreteComponentA(): string {
        return 'A';
    }
}

class ConcreteComponentB implements Component {
    /**
     * То же самое здесь:
     * visitConcreteComponentB => ConcreteComponentB
     */
    public accept(visitor: Visitor): void {
        visitor.visitConcreteComponentB(this);
    }

    public specialMethodOfConcreteComponentB(): string {
        return 'B';
    }
}

/**
 * Интерфейс Посетителя объявляет набор методов посещения,
 * соответствующих классам компонентов. Сигнатура метода
 * посещения позволяет посетителю определить конкретный класс
 * компонента, с которым он имеет дело.
 */
interface Visitor {
    visitConcreteComponentA(element: ConcreteComponentA): void;

    visitConcreteComponentB(element: ConcreteComponentB): void;
}

/**
 * Конкретные Посетители реализуют несколько версий одного и того
 * же алгоритма, которые могут работать со всеми классами 
 * конкретных компонентов.
 * Максимальную выгоду от паттерна Посетитель вы почувствуете,
 * используя его со сложной структурой объектов, такой как дерево
 * Компоновщика. В этом случае было бы полезно хранить некоторое
 * промежуточное состояние алгоритма при выполнении методов
 * посетителя над различными объектами структуры.
 */
class ConcreteVisitor1 implements Visitor {
    public visitConcreteComponentA(
        element: ConcreteComponentA
      ): void {
        console.log(
          \`$\{element.exclusiveMethodOfConcreteComponentA()}
           + ConcreteVisitor1\`
        );
    }

    public visitConcreteComponentB(
        element: ConcreteComponentB
      ): void {
        console.log(
          \`$\{element.specialMethodOfConcreteComponentB()} 
          + ConcreteVisitor1\`
        );
    }
}

class ConcreteVisitor2 implements Visitor {
    public visitConcreteComponentA(
      element: ConcreteComponentA
      ): void {
        console.log(
          \`$\{element.exclusiveMethodOfConcreteComponentA()}
           + ConcreteVisitor2\`
        );
    }

    public visitConcreteComponentB(
      element: ConcreteComponentB
      ): void {
        console.log(
          \`$\{element.specialMethodOfConcreteComponentB()}
           + ConcreteVisitor2\`
        );
    }
}
  `;

export const description = [
  `Посетитель (англ. visitor) — поведенческий шаблон проектирования, описывающий операцию, которая выполняется над
   объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.`,
  `Паттерн демонстрирует классический приём восстановления информации о потерянных типах, не прибегая
   к понижающему приведению типов при помощи двойной диспетчеризации.`,
  `Решаемая проблема:`,
  ` - Необходимо сделать какие-то несвязные операции над рядом объектов, но нужно избежать загрязнения их кода. И нет возможности
   или желания запрашивать тип каждого узла и осуществлять приведение указателя к правильному типу, прежде чем выполнить нужную операцию.`,
  `Задача:`,
  ` - Над каждым объектом некоторой структуры выполняется одна или более операций. Нужно определить новую операцию, не изменяя классы объектов.`,
  `Решение:`,
  ` - Для независимости посетитель имеет отдельную иерархию. Структуры имеют некий интерфейс взаимодействия.`,
  `Использование: `,
  ` - Если есть вероятность изменения иерархии обслуживаемого класса, либо она будет нестабильной или открытый интерфейс
    достаточно эффективен для доступа шаблона, то его использование будет вредоносным.`,
  ` - Создается базовый класс Visitor с методами visit() для каждого подкласса родительского Element. Добавьте метод 
   accept(visitor) в иерархию Element. Для каждой операции, которая должна выполняться для объектов Element, создайте 
   производный от Visitor класс. Реализации метода visit() должны использовать открытый интерфейс класса Element. 
   В результате: клиенты создают объекты Visitor и передают их каждому объекту Element, вызывая accept().`,
  `Паттерн следует использовать, если:`,
  ` - имеются различные объекты разных классов с разными интерфейсами, но над ними нужно совершать операции, зависящие от конкретных классов;`,
  ` - необходимо над структурой выполнить различные, усложняющие структуру операции;`,
  ` - часто добавляются новые операции над структурой.`,
  `Преимущества:`,
  ` - упрощается добавление новых операций;`,
  ` - объединение родственных операции в классе Visitor;`,
  ` - класс Visitor может запоминать в себе какое-то состояние по мере обхода контейнера.`,
  `Недостатки:`,
  ` - затруднено добавление новых классов, поскольку нужно обновлять иерархию посетителя и его сыновей.`,
  `Реализация:`,
  ` - Добавьте метод accept(Visitor) в иерархию «элемент».`,
  ` - Создайте базовый класс Visitor и определите методы visit() для каждого типа элемента.`,
  ` - Создайте производные классы Visitor для каждой операции, исполняемой над элементами.`,
  ` - Клиент создаёт объект Visitor и передаёт его в вызываемый метод accept().`,
];
