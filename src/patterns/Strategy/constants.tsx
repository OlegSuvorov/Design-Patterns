export const codeString =
`/**
 * Контекст определяет интерфейс, представляющий интерес для
 * клиентов.
 */
class Context {
    /**
     * @type {Strategy} Контекст хранит ссылку на один из
     * объектов Стратегии. Контекст не знает конкретного класса
     * стратегии. Он должен работать со всеми стратегиями через
     * интерфейс Стратегии.
     */
    private strategy: Strategy;

    /**
     * Обычно Контекст принимает стратегию через конструктор, а
     * также предоставляет сеттер для её изменения во время
     * выполнения.
     */
    constructor(strategy: Strategy) {
        this.strategy = strategy;
    }

    /**
     * Обычно Контекст позволяет заменить объект Стратегии во время
     * выполнения.
     */
    public setStrategy(strategy: Strategy) {
        this.strategy = strategy;
    }

    /**
     * Вместо того, чтобы самостоятельно реализовывать
     * множественные версии алгоритма, Контекст делегирует
     * некоторую работу объекту Стратегии.
     */
    public doSomeBusinessLogic(): void {
        console.log(
        'Context: Sorting data using the strategy 
        (not sure how it\\'ll do it)'
        );
        const result = this.strategy.doAlgorithm([
          'a', 'b', 'c', 'd', 'e'
        ]);
        console.log(result.join(','));
    }
}

/**
 * Интерфейс Стратегии объявляет операции, общие для всех
 * поддерживаемых версий некоторого алгоритма.
 *
 * Контекст использует этот интерфейс для вызова алгоритма,
 * определённого Конкретными Стратегиями.
 */
interface Strategy {
    doAlgorithm(data: string[]): string[];
}

/**
 * Конкретные Стратегии реализуют алгоритм, следуя базовому
 * интерфейсу Стратегии. Этот интерфейс делает их взаимозаменяемыми
 * в Контексте.
 */
class ConcreteStrategyA implements Strategy {
    public doAlgorithm(data: string[]): string[] {
        return data.sort();
    }
}

class ConcreteStrategyB implements Strategy {
    public doAlgorithm(data: string[]): string[] {
        return data.reverse();
    }
}
  `;

export const description = [
  `Стратегия (англ. Strategy) — поведенческий шаблон проектирования, предназначенный для определения семейства
   алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.`,
  `Другие объекты содержат ссылку на объект-стратегию и делегируют ей работу. Программа может подменить этот объект
   другим, если требуется иной способ решения задачи.`,
  `Это позволяет выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять
   выбранный алгоритм независимо от объектов-клиентов, которые его используют.`,
  `Задача:`,
  `По типу клиента (или по типу обрабатываемых данных) выбрать подходящий алгоритм, который следует применить.
   Если используется правило, которое не подвержено изменениям, нет необходимости обращаться к шаблону «стратегия».`,
  `Мотивы:`,
  ` - Программа должна обеспечивать различные варианты алгоритма или поведения;`,
  ` - Нужно изменять поведение каждого экземпляра класса;`,
  ` - Необходимо изменять поведение объектов на стадии выполнения;`,
  ` - Введение интерфейса позволяет классам-клиентам ничего не знать о классах, реализующих этот интерфейс и
   инкапсулирующих в себе конкретные алгоритмы;`,
  `Способ решения:`,
  ` - Отделение процедуры выбора алгоритма от его реализации. Это позволяет сделать выбор на основании контекста;`,
  `Участники:`,
  ` - Класс Strategy определяет, как будут использоваться различные алгоритмы;`,
  ` - Конкретные классы ConcreteStrategy реализуют эти различные алгоритмы;`,
  ` - Класс Context использует конкретные классы ConcreteStrategy посредством ссылки на конкретный тип абстрактного
   класса Strategy. Классы Strategy и Context взаимодействуют с целью реализации выбранного алгоритма 
   (в некоторых случаях классу Strategy требуется посылать запросы классу Context). Класс Context пересылает 
   классу Strategy запрос, поступивший от его класса-клиента.;`,
  `Следствия: `,
  ` - Шаблон Strategy определяет семейство алгоритмов;`,
  ` - Это позволяет отказаться от использования переключателей и/или условных операторов;`,
  ` - Вызов всех алгоритмов должен осуществляться стандартным образом (все они должны иметь одинаковый интерфейс);`,
  `Реализация:`,
  `Класс, который использует алгоритм (Context), включает абстрактный класс (Strategy), обладающий абстрактным методом,
   определяющим способ вызова алгоритма. Каждый производный класс реализует один требуемый вариант алгоритма.`,
  `Замечание: метод вызова алгоритма не должен быть абстрактным, если требуется реализовать некоторое поведение, принимаемое по умолчанию.`,
  `Полезные сведения:`,
  ` - И стратегия, и декоратор могут применяться для изменения поведения конкретных классов.`,
  ` - Достоинство стратегии в том, что интерфейс кастомизации не совпадает с публичным интерфейсом и может быть куда более
   удобным, а недостаток в том, что для использования стратегии необходимо изначально проектировать класс с возможностью регистрации стратегий.:`,
  `Использование:`,
  `Архитектура Microsoft WDF основана на этом паттерне. У каждого объекта «драйвер» и «устройство» есть неизменяемая часть,
   вшитая в систему, в которой регистрируется изменяемая часть (стратегия), написанная в конкретной реализации. `,
  `Изменяемая часть может быть и вовсе пустой, что даст ничего не делающий драйвер, но при этом способный участвовать в PnP и управлении питанием.`,
  `Библиотека ATL содержит в себе набор классов threading model, которые являются стратегиями (различными реализациями
   Lock/Unlock, которые потом используются основными классами системы).`,
  `При этом в этих стратегиях используется статический полиморфизм через параметр шаблона, а не динамический полиморфизм через виртуальные методы.`,
  `Стратегия часто используется в TypeScript-коде, особенно там, где нужно подменять алгоритм во время выполнения программы. Многие примеры стратегии можно заменить простыми анонимными функциями.`,
];
