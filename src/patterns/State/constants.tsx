export const codeString =
`/**
 * Контекст определяет интерфейс, представляющий интерес для
 * клиентов. Он также хранит ссылку на экземпляр подкласса
 * Состояния, который отображает текущее состояние Контекста.
 */
class Context {
    /**
     * @type {State} Ссылка на текущее состояние Контекста.
     */
    private state: State;

    constructor(state: State) {
        this.transitionTo(state);
    }

    /**
     * Контекст позволяет изменять объект Состояния во время
     * выполнения.
     */
    public transitionTo(state: State): void {
        console.log(
        \`Context: Transition to $\{state.constructor.name}.\`
        );
        this.state = state;
        this.state.setContext(this);
    }

    /**
     * Контекст делегирует часть своего поведения текущему объекту
     * Состояния.
     */
    public request1(): void {
        this.state.handle1();
    }

    public request2(): void {
        this.state.handle2();
    }
}

/**
 * Базовый класс Состояния объявляет методы, которые должны
 * реализовать все Конкретные Состояния, а также предоставляет
 * обратную ссылку на объект Контекст, связанный с Состоянием.
 * Эта обратная ссылка может использоваться Состояниями для
 * передачи Контекста другому Состоянию.
 */
abstract class State {
    protected context: Context;

    public setContext(context: Context) {
        this.context = context;
    }

    public abstract handle1(): void;

    public abstract handle2(): void;
}

/**
 * Конкретные Состояния реализуют различные модели поведения,
 * связанные с состоянием Контекста.
 */
class ConcreteStateA extends State {
    public handle1(): void {
        console.log('ConcreteStateA handles request1.');
        console.log(
        'ConcreteStateA wants to change the state of the context.'
        );
        this.context.transitionTo(new ConcreteStateB());
    }

    public handle2(): void {
        console.log('ConcreteStateA handles request2.');
    }
}

class ConcreteStateB extends State {
    public handle1(): void {
        console.log('ConcreteStateB handles request1.');
    }

    public handle2(): void {
        console.log('ConcreteStateB handles request2.');
        console.log(
        'ConcreteStateB wants to change the state of the context.'
        );
        this.context.transitionTo(new ConcreteStateA());
    }
}
  `;

export const description = [
  `Состояние (англ. State) — поведенческий шаблон проектирования. Используется в тех случаях, когда во время выполнения
   программы объект должен менять своё поведение в зависимости от своего состояния.`,
  `Паттерн состоит из 3 блоков:`,
  `Widget — класс, объекты которого должны менять своё поведение в зависимости от состояния.`,
  `IState — интерфейс, который должен реализовать каждое из конкретных состояний. Через этот интерфейс объект Widget
   взаимодействует с состоянием, делегируя ему вызовы методов.`,
  `Интерфейс должен содержать средства для обратной связи с объектом, поведение которого нужно изменить.
   Для этого используется событие (паттерн Publisher — Subscriber).`,
  `Это необходимо для того, чтобы в процессе выполнения программы заменять объект состояния при появлении событий.
   Возможны случаи, когда сам Widget периодически опрашивает объект состояния на наличие перехода.`,
  `StateA … StateZ — классы конкретных состояний. Должны содержать информацию о том, при каких условиях и в какие
   состояния может переходить объект из текущего состояния. Например, из StateA объект может переходить в состояние 
   StateB и StateC, а из StateB — обратно в StateA и так далее. Объект одного из них должен содержать Widget при создании.`,
  `Применение данного паттерна может быть затруднено, если состояния должны обмениваться данными, или одно состояние
   настраивает свойства другого. В этом случае понадобится глобальный объект, что не очень хорошее архитектурное решение.`,
  `Паттерн Состояние часто используют в TypeScript для превращения в объекты громоздких стейт-машин, построенных на операторах switch.`,
  ` - сложно добавить поддержку нового вида продуктов;`,
  `Применение:`,
  ` - система не должна зависеть от того, как создаются, компонуются и представляются входящие в неё объекты;`,
  ` - входящие в семейство взаимосвязанные объекты должны использоваться вместе и вам необходимо обеспечить выполнение 
      этого ограничения;`,
  ` - система должна конфигурироваться одним из семейств составляющих её объектов;`,
  ` - требуется предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию;`,
];
