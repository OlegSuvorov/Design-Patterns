export const codeString =
` /**
 * Базовый класс Компонент объявляет общие операции как для
 * простых, так и для сложных объектов структуры.
 */
abstract class Component {
    protected parent: Component;

    /**
     * При необходимости базовый Компонент может объявить интерфейс
     * для установки и получения родителя компонента в древовидной
     * структуре. Он также может предоставить некоторую реализацию
     * по умолчанию для этих методов.
     */
    public setParent(parent: Component) {
        this.parent = parent;
    }

    public getParent(): Component {
        return this.parent;
    }

    /**
     * В некоторых случаях целесообразно определить операции
     * управления потомками прямо в базовом классе Компонент. Таким
     * образом, вам не нужно будет предоставлять конкретные классы
     * компонентов клиентскому коду, даже во время сборки дерева
     * объектов. Недостаток такого подхода в том, что эти методы
     * будут пустыми для компонентов уровня листа.
     */
    public add(component: Component): void { }

    public remove(component: Component): void { }

    /**
     * Вы можете предоставить метод, который позволит клиентскому
     * коду понять, может ли компонент иметь вложенные объекты.
     */
    public isComposite(): boolean {
        return false;
    }

    /**
     * Базовый Компонент может сам реализовать некоторое поведение
     * по умолчанию или поручить это конкретным классам, объявив
     * метод, содержащий поведение абстрактным.
     */
    public abstract operation(): string;
}

/**
 * Класс Лист представляет собой конечные объекты структуры. Лист
 * не может иметь вложенных компонентов.
 *
 * Обычно объекты Листьев выполняют фактическую работу, тогда как
 * объекты Контейнера лишь делегируют работу своим подкомпонентам.
 */
class Leaf extends Component {
    public operation(): string {
        return 'Leaf';
    }
}

/**
 * Класс Контейнер содержит сложные компоненты, которые могут
 * иметь вложенные компоненты. Обычно объекты Контейнеры
 * делегируют фактическую работу своим детям, а затем
 * «суммируют» результат.
 */
class Composite extends Component {
    protected children: Component[] = [];

    /**
     * Объект контейнера может как добавлять компоненты в свой
     * список вложенных компонентов, так и удалять их, как простые,
     * так и сложные.
     */
    public add(component: Component): void {
        this.children.push(component);
        component.setParent(this);
    }

    public remove(component: Component): void {
        const componentIndex = this.children.indexOf(component);
        this.children.splice(componentIndex, 1);

        component.setParent(null);
    }

    public isComposite(): boolean {
        return true;
    }

    /**
     * Контейнер выполняет свою основную логику особым образом.
     * Он проходит рекурсивно через всех своих детей, собирая и
     * суммируя их результаты. Поскольку потомки контейнера
     * передают эти вызовы своим потомкам и так далее, в
     * результатеобходится всё дерево объектов.
     */
    public operation(): string {
        const results = [];
        for (const child of this.children) {
            results.push(child.operation());
        }

        return \`Branch($\{results.join('+')})\`;
    }
}
  `;

export const description = [
  `Компоновщик (англ. Composite pattern) — структурный шаблон проектирования, объединяющий объекты в древовидную 
  структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным 
  объектам и к группам объектов одинаково.`,
  `Паттерн определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает
   архитектуру клиента, делает процесс добавления новых видов объекта более простым.`,
  `Паттерн Компоновщик встречается в любых задачах, которые связаны с построением дерева. Самый простой пример —
   составные элементы GUI, которые тоже можно рассматривать как дерево.`,
  `Признаки применения паттерна: Если из объектов строится древовидная структура, и со всеми объектами дерева, как и с 
  самим деревом работают через общий интерфейс.`,
];
